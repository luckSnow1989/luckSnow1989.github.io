# 架构设计

## 设计原则

规则一、避免过度设计
内容：在设计中要警惕复杂的解决方案
用法：通过测试同事是否能够轻松地理解解决方案来验证是否存在过度设计
原因：复杂的解决方案实施成本过高，而且长期的维护费用昂贵
要点：复杂的系统限制了扩展性。简单的系统易维护，易扩展且成本低

规则二、方案中包括扩展
内容：提供及时可扩展性的DID方法
用法：Design(D)设计20倍的容量；Implement(I)实施3倍的容量；Deploy（D）部署1.5倍的容量
原因：DID为产品扩展提供了经济，有效，及时的方法
要点：在早期考虑可扩展性可以帮助团队节省时间和金钱。在需求发生大约一个月前实施（写代码），在客户蜂拥而至的几天前部署。

规则三-三次简化方案
内容：在设计复杂系统时，从项目的范围、设计和实施角度简化方案
用法：采用帕累托（Pareto）原则简化范围；考虑成本优化和可扩展性来简化设计；依靠其他人的经验来简化部署；
原因：只聚焦“不过度复杂”，并不能解决需求或历史发展与变革中的各种问题
要点：在产品研发的各个阶段都需要做好简化

## 性能优化
- [软件设计杂谈——性能优化的十种手段（上篇）](https://code2life.top/2020/08/15/0055-performance/)
- [软件设计杂谈——性能优化的十种手段（中篇）](https://code2life.top/2020/08/14/0056-performance2/)
- [软件设计杂谈——性能优化的十种手段（下篇）](https://code2life.top/2020/08/13/0056-performance3/)

性能优化通常是“时间”与“空间”的互换与取舍
- 索引术。比如数据库中的索引技术，数据结构，字段类型，使用注意事项（聚簇索引、索引覆盖）
- 压缩术。时间换空间。操作系统内核与网络设备处理负担 vs 压缩解压的CPU/GPU负担
- 缓存术。DNS缓存、浏览器缓存、应用程序缓存、数据库缓存、操作系统缓存、CPU缓存。甚至一些复用技术也算是缓存的一种应用方式。
- 预取术。原理是在缓存空间换时间基础上，用事先预取的耗时，换取第一次加载的时间
- 削峰填谷术。原理也是“时间换时间”。预取是事先花时间做，削峰填谷是事后花时间做
- 批量处理术。批量处理同样可以看成“时间换时间”，其原理是减少了重复的事情，是一种对执行流程的压缩

提升并行能力
- 榨干计算资源。零拷贝技术，epool，CPU亲和性
- 水平扩容。水平扩容的前提是无状态
- 分片术。水平扩容针对无状态组件，分片针对有状态组件。二者原理都是提升并行度，但分片的难度更大。负载均衡也不再是简单的加权轮询了，而是进化成了各个分片的协调器
- 无锁术。不管是单机还是分布式微服务，锁都是制约并行度的一大因素

## 代码分层设计

<div name="wordShowDiv" word-url="file/项目分层架构.docx"></div>

- MVC
- 分层架构
- COLA

## 项目设计

### 1.设计上的误区
- 服务拆分的误解:
  感觉自己被鼓励'每个服务搞一个 git'。那，你这个服务里访问 db 的代码，rpc 的代码，各种可以复用的代码，是用的大家都复用的 git 下的代码么？
  每次都重复写一遍，db 字段细节改了，每个使用过 db 的 server 对应的 git 都改一遍？这个通用 git 已经写好的接口应该不知道哪些 git 
  下的代码因为自己不向前兼容的修改而永远放弃了向前不兼容的修改？ 至少一类功能的数据放在一个db中，一个服务尽可能只访问一个db。
  一个db仅提供一个服务访问。否则项目复杂度会越来越高

- 早期有效的决策不再有效:将本来简单的逻辑，不断迭代复杂化，以至于无法重构

- 总是面向对象/总喜欢封装:
  即使是对简单的业务模型，也需要无数次'坏'的对象抽象实践，才能培养出一个具有合格的 class 抽象能力的同学，这对于大型却松散的团队协作，不是破坏性的？
  已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的 class，以及使用它们的地方，你都去改？
  不，是个正常人都会放弃，开始堆屎山。 使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，
  我们还要强调函数内部工作方式'可以让读者在大脑里想象呈现完整过程'的可现性，让使用者轻松读懂，有把握，使用时，不迷路

### 2.model设计

没读过 oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个撇脚的 oauth。
不懂 Unix 的人注定最终还要重复发明一个撇脚的 Unix。--Henry Spenncer, 1987.11

- 一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？
- 一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的 ife lse？
- 你联通有上万台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的 ife lse？

你必须要有 Domain 思考探索、model 拆解/抽象/构建的能力。
唯一回答就是，进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力，去进一步思考。至于怎么建立好的通识思考能力，可能得去常青藤读个书吧：）或者，就在工程实践中思考和锻炼自己的这个能力！

案例：同时，基于 model 设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个 calendar(日历)应用，简单来想，不要太简单！
以'userid_date'为 key 记录一个用户的每日安排不就完成了么？只往前走一步，设计了一个任务，上限分发给 100w 个人，创建这么一个任务，
是往 100w 个人下面添加一条记录？你得改掉之前的设计，换 db。再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做 join？好像还行。
如果是和 100 个人一起参与的所有任务呢？100 个人的任务来 join？不现实了吧。好，你引入一个群组 id，那么，你最开始的'userid_date'为 key 的设计，
是不是又要修改和做数据迁移了？经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？
你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个 model，设计一套通用的 store 层接口，
基于通用接口的逻辑代码。当产品不断发展，就是不停往模型里填内容，而不是推翻重来。这，思考模型边界，构建模型细节，就是两个很重要的能力，
也是绝大多数腾讯产品经理不具备的能力，你得具备，对整个团队都是极其有益的。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。

### 3.KISS 原则

keep it simple stuped
首先，简单不是面对一个问题，我们印入眼帘第一映像的解法为简单。我说一句，感受一下。把一个事情做出来容易，把事情用最简单有效的方法做出来，是一个很难的事情。
比如，做一个三方授权，oauth2.0 很简单，所有概念和细节都是紧凑、完备、易用的。你觉得要设计到 oauth2.0 这个效果很容易么？
要做到简单，就要对自己处理的问题有全面的了解，然后需要不断积累思考，才能做到从各个角度和层级去认识这个问题，打磨出一个通俗、紧凑、完备的设计，
就像 ios 的交互设计。简单不是容易做到的，需要大家在不断的时间和 code review 过程中去积累思考，pk 中触发思考，交流中总结思考，才能做得愈发地好，接近'大道至简'。

## 架构模式

<div name="wordShowDiv" word-url="file/软件框架模式.docx"></div>

## 公司技术委员会职责

<div name="wordShowDiv" word-url="file/公司技术委员会职责.docx"></div>