---
sort: 4
---
# 4.事务

都是基于 InnoDB 进行解释。redolog + undolog 日志，是 InnoDB 的底层能力。binlog 是mysql server的通用能力。

## 1.数据库事务管理

我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，
任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。

事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。

## 2.ACID

### 2.1.什么是ACIO

事务的四大特性ACID：
1. 原子性(atomicity)： 事务的最小工作单元，要么全成功，要么全失败。
2. 一致性(consistency)： 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
3. 隔离性(isolation)： 一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
   四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE（串行化）。
4. 持久性(durability)： 事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失。

### 2.2.MySQL是怎么保证ACID的？
1. 原子性：是由undolog日志保证的，它记录了需要回滚的日志信息，事务回滚时撤销已经执行的SQL。使用锁确保同一时刻只有一个事务可以操作数据。
2. 一致性：有其他三个特性共同保证的，程序代码要保证业务上的一致性。
3. 隔离性：由MVCC来保证的
4. 持久性：由redolog来保证，MySQL修改数据的时候会在redolog中记录一份日志，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。

## 3.隔离级别

查看数据库默认隔离级别： select @@tx_isolation

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。
低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

1. 读未提交：READ-UNCOMMITED，又称为脏读，一个事务可以读取到另一个事务未提交的数据。这种隔离级别最不安全。
2. 读已提交：READ-COMMITED，又称为不可重复读，一个事务因为读取到另一个已提交的修改数据，导致当前事务中不同时间读取的数据不一致。
3. 可重复读：REPEATABLE-READ，又称为幻读，一个事务可以读取到其他事务提交的数据，但是在RR隔离级别下，当前读取此数据只可读取一次，
    在当前事务中，不论读取多少次，数据仍然是第一次读取的值，不会因为在第一次读取之后，其他事务对数据修改并提交了而发生不一致。
4. 串行化：SERIALIZABLE，所有的数据库的读或写操作都是串行化的，当前隔离级别下只同一时刻只有一个事务在执行，所有事务都要排队等待

|                                | 脏读 | 不可重复读 | 幻读           |
| -------------------------------- | ------ | ------------ | ---------------- |
| read uncommited（未提交读，1） | Y    | Y          | Y              |
| read commited（已提交读，2）   | N    | Y          | Y              |
| repeatable read（可重复读，4） | N    | N          | Y（高版本是N） |
| serializable（串行化，8）      | N    | N          | N              |

- Oracle 默认 read commited
- Mysql 默认 repeatable read

很多时候，不可重复读并不是问题，并且RR级别存在间隙锁降低性能，所以在很多互联网场景使用RC

### 3.1.脏读(Drity Read)

某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

### 3.2.不可重复读(Non-repeatable read)

在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

### 3.3.幻读(Phantom Read)

- 前提条件：InnoDB引擎，可重复读隔离级别，使用当前读时。
- 表现：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。两点需要说明：

1. 在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。
2. 幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。

- 幻读的影响

会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，
而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。

- 幻读产生的原因

行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。

- 如何解决幻读

将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁。
间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作。

### 3.4.常见问题

<p style="color: red;">事务隔离级别怎么实现的？</p>

总结：锁+mvcc机制

1. 读未提交：READ-UNCOMMITED，没有锁，也不隔离，最不安全。
2. 读已提交：READ-COMMITED，有行锁，数据被锁时，别的事务无法更改，每次读取最新提交的数据。
3. 可重复读：REPEATABLE-READ，有行锁，数据被锁时，别的事务无法更改，记录第一次读取时提交的数据(undo日志）,之后在事务内都读取这个副本。
    mysql进行了优化，引入next key lock ，解决了幻读的问题。
4. 串行化：SERIALIZABLE，表锁，读写都串行，不需要mvcc。

[https://www.cnblogs.com/Genesisx/p/9139175.html](https://www.cnblogs.com/Genesisx/p/9139175.html)

<p style="color: red;">不可重复读和幻读的区别</p>

[https://www.cnblogs.com/itcomputer/articles/5133254.html](https://www.cnblogs.com/itcomputer/articles/5133254.html)

对于前者, 数据多次读取到的数据值不同，解决方案：mvcc机制

对于后者, 单个查询语句多次查询到的数据量不同，解决方案：next key lock

<p style="color: red;">可重复读和幻读的区别？</p>

[https://www.cnblogs.com/itcomputer/articles/5133254.html](https://www.cnblogs.com/itcomputer/articles/5133254.html)

- 可重复读，是为了解决在隔离级别是RC时，同一条数据两次读取的结果不同。解决的方案是在隔离级别RR，通过多版本控制（mvcc）实现的。不涉及到锁

- 幻读，是在RR隔离级别时，某个范围内查询数据，两次查询出来的数据量不同。
  解决方式是要锁住满足条件及其相近的记录，针对的是包括单行数据在内的一个区间的数据。其实就是锁的机制，范围不一样的。也就是next-key锁。使用的时候，必须使用当前读；快照读的时候，只会加间隙锁。

<p style="color: red;">可重复读怎么解决的？</p>

不可重复读，是指的单行的数据；幻读指的是一定范围的数据；

在RC级别下，普通的查询SQL，每次读取的都是最新的数据，所以会出现不可重复度的问题。

在RR级别解决了重复读。采用mvcc机制

Mvcc原理，多版本并发控制，读取的时候有快照读和直接读，和锁没有关系。

Mvcc是通过在表中增加2个隐藏列，其中包括一个版本号

```sql
Begin -- 开启事务

Select * from table_name where id=1; // 版本号是1

// 业务代码... // 别的事务将这条数据改了，版本号已经是2了

Select * from table_name where id=1; //
再查询，这条数据的版本号还是1，这样防止幻读，同时实现可重复度

Commit; -- 提交事务
```

<p style="color: red;">幻读怎么解决的</p>

不可重复读，是指的单行的数据；幻读指的是一定范围的数据；在RR级别解决了重复读。

Mvcc只能保存第一次查询出来的数据是快照数据，如果查询条件的范围内，增加了数据，后面就出现幻读了。

[https://blog.csdn.net/sanyuesan0000/article/details/90235335](https://blog.csdn.net/sanyuesan0000/article/details/90235335)

第一个方式是事务隔离级别改成串行

第二个是：RR级别使用：next-key lock。

next-key locks由record locks(索引加锁/行锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)的结合，
next-key lock 会锁定范围和自身行，比如select...where id<6，锁定的是小于6的行和等于6的行

## 4.mvcc

### 4.1.实现原理


### 4.2.常见问题

<p style="color:red;">使用快照读的时候，会加锁吗？</p>

开始事务后，普通的SQL查询，查询到的数据数快照数据，不会加锁。这里的普通SQL指的是通过主键或索引查询到的单行数据，才不加锁。

如果SQL查询的是一个范围或者是多条的数据，是会加锁的，比如间隙锁。

想要获得当前读的话，只有下面5种场景：

- select * from table where ? lock in share mode;
  共享锁，别的事务可以读，但是不能写

- select * from table where ? for update; 独占锁、悲观锁

- insert;

- update ;

- delete;

## 5.spring中的事务

[spring中的事务](/article/9.框架/spring/5.Spring%20事务)

隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。