---
sort: 0
---
# 2.共识算法

共识算法，也称为分布式数据一致性算法。

1. Paxos：被认为是分布式共识算法的根本，其他都是其变种，但是 paxos 论文中只给出了单个提案的过程，
并没有给出复制状态机中需要的 multi-paxos 的相关细节的描述，实现 paxos 具有很高的工程复杂度 （如多点可写，允许日志空洞等）。
2. Zab：被应用在 zookeeper 中，业界使用广泛，但没用抽象成通用 library。
3. Raft： 以容易理解著称，业界也涌现出很多 raft 实现，比如 etcd、braft、tikv 等。
   - https://mp.weixin.qq.com/s/ZE3sXRWoZYgbSIPTYIHWoA
   - [分布式一致性Raft与JRaft](https://www.cnblogs.com/yulinfu/p/15410107.html)
   - [深入解读Raft算法与etcd工程实现](https://mp.weixin.qq.com/s/x-AdmN0UN5KT58XWO1BCOA)
   - 开源的代码：
     - braft。百度开源的使用c++实现的raft算法。 [https://github.com/baidu/braft](https://github.com/baidu/braft)
     - SOFAJRaft。蚂蚁金服借鉴braft使用Java使用的raft算法。[https://www.sofastack.tech/projects/sofa-jraft/overview/](https://www.sofastack.tech/projects/sofa-jraft/overview/)
4. Gossip： 与上面三种不同，是一种数据复制算法，比如 redis
https://zhuanlan.zhihu.com/p/41228196


## Raft

Raft协议对标Paxos，容错性和性能都是一致的，但是Raft比Paxos更易理解和实施。Raft协议把Leader选举、日志复制、安全性等功能分离并模块化，使其更易理解和工程实现。
目前很多中间件都开始使用Raft协议

节点角色：Leader（发出提案）、Follower（参与决策）、Candidate（Leader选举中的临时角色）。

选举过程：
刚开始所有节点都是Follower状态，然后进行Leader选举。成功后Leader接受所有客户端的请求，然后把日志entry发送给所有Follower，
当收到过半的节点的回复（而不是全部节点）时就给客户端返回成功并把commitIndex设置为该entry的index，所以是满足最终一致性的。

心跳机制：
Leader同时还会周期性地发送心跳给所有的Follower（会通过心跳同步提交的序号commitIndex）， Follower收到后就保持Follower状态（并应用commitIndex及其之前对应的日志entry），
如果Follower等待心跳超时了，则开始新的Leader选举：
1. 首先把当前term计数加1，自己成为Candidate，
2. 然后给自己投票并向其它结点发投票请求。直到以下三种情况：
   - 它赢得选举；
   - 另一个节点成为Leader；
   - 一段时间没有节点成为Leader。
3. 在选举期间，Candidate可能收到来自其它自称为Leader的写请求，如果该Leader的term不小于Candidate的当前term，那么Candidate承认它是一个合法的Leader并回到Follower状态，否则拒绝请求。
4. 如果出现两个Candidate得票一样多，则它们都无法获取超过半数投票，这种情况会持续到超时，然后进行新一轮的选举，这时失败的概率就很低了，那么首先发出投票请求的的Candidate就会得到大多数同意，成为Leader。

## Gossip

[一致性算法-Gossip协议详解](https://cloud.tencent.com/developer/article/1662426)

### 介绍

Gossip协议又被称为流行病协议（Epidemic Protocol），也有人叫它反熵（Anti-Entropy）。

Gossip协议于1987年在ACM上发表的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出，
主要用在分布式数据库系统中各个副本节点间的数据同步，这种场景的一个最大特点就是组成网络的节点都是对等的，网络中即使有的节点因宕机而重启，
或有新节点加入，但经过一段时间后，这些节点的状态也会与其他节点达成一致。

**简而言之，Gossip是一种数据复制算法，并不是共识算法。作用是在将数据传播到集群各个节点，因此Gossip也算是一种带冗余的分布式容错的算法，可以实现数据的最终一致性。**

使用场景：最终一致性的场景（也就是AP场景）：
- 失败检测
- 路由同步
- Pub/Sub
- 动态负载均衡。

使用案例
- Bitcoin:使用 Gossip 协议来传播交易和区块信息，
- Redis： cluster方式使用Gossip进行检活和数据同步
- Consul

缺点也很明显：
- 消息延迟：节点随机向少数几个节点发送消息，消息最终是通过多个轮次的散播才能遍布集群。
- 消息冗余：节点定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤。节点越多，对带宽和CPU的消耗越大。
- 拜占庭问题：如果有一个恶意传播消息的节点，Gossip协议的分布式系统就会出问题。

### 六度分隔理论

- 原文：“你与任何一个陌生人之间间隔的人不会超过6个”
- 案例：Facebook研究发现已经注册的15.9亿用户，网络半径为4.57。

### 节点状态

- S:Suspective(病原)：处于 susceptible 状态的节点代表其并没有收到来自其他节点的更新。
- I:Infective(感染)：处于 infective 状态的节点代表其有数据更新，并且会将这个数据分享给其他节点。
- R:Removed(愈除):其已经接收到来自其他节点的更新，但是其并不会将这个更新分享给其他节点。

R状态的引入，是为了避免产生传播风暴，及时出现也会在可控的时间范围内自行恢复。

### 复制方式
Gossip将数据复制协议分为两种
- 反熵传播：定时随机选择节点，几个节点相互交换全部数据来消除数据差异。
  - 参与节点只有两种状态(SI)
  - 缺点：交换数据会带来很大的通讯负担，通常不会频繁使用
  - 使用场景：通常用于新加入集群的节点初始化数据
- 谣言传播：定时随机选择节点，将某段时间内最新的数据进行发送（同一条数据可能发送多次），直到消息被标记为R，就停止传播。
  - 参与节点有三种状态(SIR)
  - 缺点：有一定的概率出现数据不一致的情况
  - 使用场景：通常用于节点间数据增量同步

Gossip实际使用中，为了在通信代价和可靠性之间取得折中，需要将这两种方法结合使用。启动是反熵传播，之后谣言传播。


### 通讯方式
Gossip 协议最终目的是将数据分发到网络中的每一个节点。节点间通信方式：Push、Pull 以及 Push&Pull：
- Push: 产生新数据的节点作为发起节点。发起信息交换的节点 A 随机选择联系节点 B，并向其发送自己的信息，节点 B 在收到信息后更新比自己新的数据。
- Pull：无新数据的节点作为发起节点。发起信息交换的节点 A 随机选择联系节点 B，并从对方获取信息。
- Push&Pull：发起信息交换的节点 A 向选择的节点 B 发送信息，同时从对方获取数据，用于更新自己的本地数据。

如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push&Pull 则需 3 次。
虽然消息次数多了，但从效果上来讲，Push&Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push&Pull 的收敛速度也是最快的。
